"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.r = void 0;
const connection_1 = require("../connection/connection");
const master_pool_1 = require("../connection/master-pool");
const error_1 = require("../error/error");
const types_1 = require("../types");
const globals_1 = require("./globals");
const query_config_1 = require("./query-config");
const query_1 = require("./query");
const query_runner_1 = require("./query-runner");
const validate_term_1 = require("./validate-term");
const param_parser_1 = require("./param-parser");
const expr = (arg, nestingLevel = globals_1.globals.nestingLevel) => {
    if (query_1.isQuery(arg)) {
        return arg;
    }
    return query_runner_1.toQuery(param_parser_1.parseParam(arg, nestingLevel));
};
exports.r = expr;
exports.r.connectPool = async (options = {}) => {
    const { host, port, server = { host, port }, servers = [server], waitForHealthy = true, } = options;
    if (host || port) {
        if (options.server) {
            throw new error_1.RethinkDBError('If `host` or `port` are defined `server` must not be.', { type: types_1.RethinkDBErrorType.API_FAIL });
        }
        else if (options.servers) {
            throw new error_1.RethinkDBError('If `host` or `port` are defined `servers` must not be.', { type: types_1.RethinkDBErrorType.API_FAIL });
        }
    }
    if (options.server && options.servers) {
        throw new error_1.RethinkDBError('If `server` is defined `servers` must not be.', {
            type: types_1.RethinkDBErrorType.API_FAIL,
        });
    }
    if (!servers.length) {
        throw new error_1.RethinkDBError('If `servers` is an array, it must contain at least one server.', { type: types_1.RethinkDBErrorType.API_FAIL });
    }
    if (exports.r.pool) {
        exports.r.pool.removeAllListeners();
        exports.r.pool.drain();
    }
    const cpool = new master_pool_1.MasterConnectionPool(Object.assign(Object.assign({}, options), { servers }));
    exports.r.pool = cpool;
    cpool.initServers().catch(() => undefined);
    return waitForHealthy ? await cpool.waitForHealthy() : cpool;
};
exports.r.connect = async (options = {}) => {
    const { host, port, server = { host, port } } = options;
    if ((host || port) && options.server) {
        throw new error_1.RethinkDBError('If `host` or `port` are defined `server` must not be.', { type: types_1.RethinkDBErrorType.API_FAIL });
    }
    const c = new connection_1.RethinkDBConnection(server, options);
    await c.reconnect();
    return c;
};
exports.r.getPoolMaster = () => exports.r.pool;
exports.r.waitForHealthy = () => {
    if (exports.r.pool) {
        return exports.r.pool.waitForHealthy();
    }
    throw new error_1.RethinkDBError('Pool not initialized', {
        type: types_1.RethinkDBErrorType.MASTER_POOL_FAIL,
    });
};
exports.r.setNestingLevel = (level) => {
    globals_1.globals.nestingLevel = level;
};
exports.r.setArrayLimit = (limit) => {
    globals_1.globals.arrayLimit = limit;
};
// @ts-ignore
exports.r.serialize = (termStr) => JSON.stringify(termStr.term);
// @ts-ignore
exports.r.deserialize = (termStr) => query_runner_1.toQuery(validate_term_1.validateTerm(JSON.parse(termStr)));
// @ts-ignore
exports.r.expr = expr;
// @ts-ignore
exports.r.do = (...args) => {
    const last = args.pop();
    return query_1.termBuilder(query_config_1.funcall, query_runner_1.toQuery)(last, ...args);
};
query_config_1.rConfig.forEach((config) => (exports.r[config[1]] = query_1.termBuilder(config, query_runner_1.toQuery)));
query_config_1.rConsts.forEach(([type, name]) => (exports.r[name] = query_runner_1.toQuery([type])));
query_config_1.termConfig
    .filter(([_, name]) => !(name in exports.r))
    .forEach(([type, name, minArgs, maxArgs, optArgs]) => (exports.r[name] = query_1.termBuilder([
    type,
    name,
    minArgs + 1,
    maxArgs === -1 ? maxArgs : maxArgs + 1,
    optArgs,
], query_runner_1.toQuery)));
