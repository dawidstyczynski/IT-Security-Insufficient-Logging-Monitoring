"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.toQuery = void 0;
const query_config_1 = require("./query-config");
const connection_1 = require("../connection/connection");
const types_1 = require("../types");
const r_1 = require("./r");
const error_1 = require("../error/error");
const term_backtrace_1 = require("../error/term-backtrace");
const query_1 = require("./query");
const doTermFunc = (termQuery) => {
    return (...args) => {
        const last = args.pop();
        const tb = query_1.termBuilder(query_config_1.funcall, toQuery);
        return last ? tb(last, termQuery, ...args) : tb(termQuery);
    };
};
const runQueryFunc = (term) => {
    return async (conn, options) => {
        const c = conn instanceof connection_1.RethinkDBConnection ? conn : undefined;
        const cpool = r_1.r.getPoolMaster();
        const opt = conn instanceof connection_1.RethinkDBConnection ? options : conn;
        if (!c && (!cpool || cpool.draining)) {
            throw new error_1.RethinkDBError('`run` was called without a connection and no pool has been created after:', { term, type: types_1.RethinkDBErrorType.API_FAIL });
        }
        const cursor = c ? await c.query(term, opt) : await cpool.queue(term, opt);
        if (cursor) {
            const results = await cursor.resolve();
            if (results) {
                switch (cursor.getType()) {
                    case 'Atom':
                        return cursor.profile
                            ? { profile: cursor.profile, result: results[0] }
                            : results[0];
                    case 'Cursor':
                        return cursor.profile
                            ? { profile: cursor.profile, result: await cursor.toArray() }
                            : await cursor.toArray();
                    default:
                        return cursor;
                }
            }
        }
    };
};
const getCursorQueryFunc = (term) => {
    return async (conn, options) => {
        const c = conn instanceof connection_1.RethinkDBConnection ? conn : undefined;
        const cpool = r_1.r.getPoolMaster();
        const opt = conn instanceof connection_1.RethinkDBConnection ? options : conn;
        if (!c && (!cpool || cpool.draining)) {
            throw new error_1.RethinkDBError('`getCursor` was called without a connection and no pool has been created after:', { term, type: types_1.RethinkDBErrorType.API_FAIL });
        }
        const cursor = c ? await c.query(term, opt) : await cpool.queue(term, opt);
        if (cursor) {
            cursor.init();
            // @ts-ignore
            return cursor;
        }
    };
};
function toQuery(term) {
    const query = query_1.termBuilder(query_config_1.bracket, toQuery, term);
    query.term = term;
    query[query_1.querySymbol] = true;
    query.toString = () => term_backtrace_1.backtraceTerm(term)[0];
    query.run = runQueryFunc(term);
    query.getCursor = getCursorQueryFunc(term);
    query.do = doTermFunc(query);
    for (let i = 0; i < query_config_1.termConfig.length; i += 1) {
        const config = query_config_1.termConfig[i];
        query[config[1]] = query_1.termBuilder(config, toQuery, term);
    }
    return query;
}
exports.toQuery = toQuery;
