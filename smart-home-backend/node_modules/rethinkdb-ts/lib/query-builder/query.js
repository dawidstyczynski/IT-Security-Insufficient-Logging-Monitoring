"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.termBuilder = exports.isQuery = exports.querySymbol = void 0;
const types_1 = require("../types");
const error_1 = require("../error/error");
const enums_1 = require("../proto/enums");
const param_parser_1 = require("./param-parser");
const parse_opt_arg_1 = require("./parse-opt-arg");
exports.querySymbol = Symbol('RethinkDBQuery');
const isQuery = (query) => query === Object(query) && Object.hasOwnProperty.call(query, exports.querySymbol);
exports.isQuery = isQuery;
const numToStringArr = ['', 'First', 'Second', 'Third', 'Fourth', 'Fifth'];
function numToString(num) {
    return numToStringArr.map((_, i) => i).includes(num)
        ? numToStringArr[num]
        : num.toString();
}
function termBuilder([termType, termName, minArgs, maxArgs, optargType], toQuery, currentTerm) {
    return (...args) => {
        let optarg;
        const params = currentTerm !== undefined ? [currentTerm] : [];
        // @ts-ignore
        if (exports.isQuery(args[0]) && args[0].term[0] === enums_1.TermType.ARGS) {
            params.push(param_parser_1.parseParam(args[0]));
            optarg = optargType !== false ? args[1] : undefined;
        }
        else {
            const argsLength = args.length;
            if (minArgs === maxArgs && argsLength !== minArgs) {
                throw new error_1.RethinkDBError(`\`${!currentTerm ? `r.${termName}` : termName}\` takes ${minArgs} argument${minArgs === 1 ? '' : 's'}, ${argsLength} provided${!currentTerm ? '.' : ' after:'}`, { term: currentTerm, type: types_1.RethinkDBErrorType.ARITY });
            }
            if (argsLength < minArgs) {
                throw new error_1.RethinkDBError(`\`${!currentTerm ? `r.${termName}` : termName}\` takes at least ${minArgs} argument${minArgs === 1 ? '' : 's'}, ${argsLength} provided${!currentTerm ? '.' : ' after:'}`, { term: currentTerm, type: types_1.RethinkDBErrorType.ARITY });
            }
            if (maxArgs !== -1 && argsLength > maxArgs) {
                throw new error_1.RethinkDBError(`\`${!currentTerm ? `r.${termName}` : termName}\` takes at most ${maxArgs} argument${maxArgs === 1 ? '' : 's'}, ${argsLength} provided${!currentTerm ? '.' : ' after:'}`, { term: currentTerm, type: types_1.RethinkDBErrorType.ARITY });
            }
            switch (optargType) {
                case 'last':
                    // @ts-ignore
                    optarg = parse_opt_arg_1.parseOptarg(args[maxArgs - 1]);
                    break;
                case 'required':
                case 'optional':
                case 'last-optional':
                    // @ts-ignore
                    optarg = parse_opt_arg_1.parseOptarg(args[argsLength - 1]);
            }
            if (!optarg &&
                (optargType === 'required' ||
                    (argsLength === maxArgs &&
                        ['last', 'last-optional'].includes(optargType)))) {
                throw new error_1.RethinkDBError(`${numToString(argsLength)} argument of \`${termName}\` must be an object.`, { term: currentTerm, type: types_1.RethinkDBErrorType.ARITY });
            }
            params.push(...args
                .filter((_, i) => (optarg ? i < argsLength - 1 : true))
                .map((x) => param_parser_1.parseParam(x)));
        }
        const term = [termType];
        if (params.length > 0) {
            term[1] = params;
        }
        if (optarg) {
            term[2] = optarg;
        }
        return toQuery(term);
    };
}
exports.termBuilder = termBuilder;
