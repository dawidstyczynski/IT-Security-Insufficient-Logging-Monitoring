"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isRethinkDBError = exports.RethinkDBError = void 0;
const types_1 = require("../types");
const enums_1 = require("../proto/enums");
const globals_1 = require("../query-builder/globals");
const term_backtrace_1 = require("./term-backtrace");
function pretty(query, mark) {
    let result = '';
    let indent = 0;
    const openIndentPos = [];
    let char = '';
    let newline = true;
    let inStr = false;
    let shouldEscape = false;
    let lastNewlinePos = 0;
    let lineMarkPos = 0;
    let lineMark = '';
    let nextSign = '';
    let isLastIndentDot = false;
    const openBrackets = [];
    for (let i = 0; i < query.length; i += 1) {
        char = query.charAt(i);
        if (!inStr) {
            if (['{', '(', '['].includes(char)) {
                openBrackets.unshift(char);
            }
            else if ((char === '}' && openBrackets[0] === '{') ||
                (char === ')' && openBrackets[0] === '(') ||
                (char === ']' && openBrackets[0] === '[')) {
                openBrackets.shift();
            }
        }
        switch (char) {
            case '.':
                shouldEscape = false;
                newline = false;
                if (inStr || result.length - lastNewlinePos <= 80 + indent) {
                    result += char;
                }
                else {
                    if (!isLastIndentDot) {
                        indent += 4;
                    }
                    lineMark += mark.substring(lineMarkPos, i);
                    lineMarkPos = i + 1;
                    result = result.trimRight();
                    nextSign =
                        lineMark.charAt(result.length - lastNewlinePos) || mark.charAt(i);
                    lineMark = lineMark.substring(0, result.length - lastNewlinePos);
                    result += lineMark.includes('^')
                        ? `\n${lineMark}\n${' '.repeat(indent)}.`
                        : `\n${' '.repeat(indent)}.`;
                    lastNewlinePos = result.length - indent - 1;
                    lineMark = ' '.repeat(indent) + nextSign;
                    isLastIndentDot = true;
                }
                break;
            case ',':
                if (inStr || openBrackets[0] !== '{') {
                    newline = false;
                    result += char;
                }
                else {
                    newline = true;
                    lineMark += mark.substring(lineMarkPos, i + 1);
                    lineMarkPos = i + 1;
                    result += lineMark.includes('^')
                        ? `,\n${lineMark}\n${' '.repeat(indent)}`
                        : `,\n${' '.repeat(indent)}`;
                    lastNewlinePos = result.length - indent;
                    lineMark = ' '.repeat(indent);
                }
                break;
            case '{':
                shouldEscape = false;
                if (inStr || query.charAt(i + 1) === '}') {
                    newline = false;
                    result += char;
                }
                else {
                    newline = true;
                    openIndentPos.push(indent);
                    isLastIndentDot = false;
                    indent += 4;
                    lineMark += mark.substring(lineMarkPos, i + 1);
                    lineMarkPos = i + 1;
                    result += lineMark.includes('^')
                        ? `{\n${lineMark}\n${' '.repeat(indent)}`
                        : `{\n${' '.repeat(indent)}`;
                    lastNewlinePos = result.length - indent;
                    lineMark = ' '.repeat(indent);
                }
                break;
            case '}':
                newline = false;
                shouldEscape = false;
                if (inStr || query.charAt(i - 1) === '{') {
                    result += char;
                }
                else {
                    indent = openIndentPos.pop() || 0;
                    lineMark += mark.substring(lineMarkPos, i);
                    lineMarkPos = i + 1;
                    result = result.trimRight();
                    nextSign =
                        lineMark.charAt(result.length - lastNewlinePos) || mark.charAt(i);
                    lineMark = lineMark.substring(0, result.length - lastNewlinePos);
                    result += lineMark.includes('^')
                        ? `\n${lineMark}\n${' '.repeat(indent)}}`
                        : `\n${' '.repeat(indent)}}`;
                    lastNewlinePos = result.length - indent - 1;
                    lineMark = ' '.repeat(indent) + nextSign;
                }
                break;
            case ' ':
                shouldEscape = false;
                if (newline) {
                    lineMarkPos += 1;
                }
                else {
                    result += char;
                }
                break;
            case '"':
                if (shouldEscape) {
                    shouldEscape = false;
                }
                else {
                    inStr = !inStr;
                }
                newline = false;
                result += char;
                break;
            case '\\':
                shouldEscape = !escape;
                newline = false;
                result += char;
                break;
            default:
                shouldEscape = false;
                newline = false;
                result += char;
                break;
        }
    }
    lineMark += mark.substring(lineMarkPos, query.length);
    result = result.trimRight();
    lineMark = lineMark.substring(0, result.length - lastNewlinePos);
    result += lineMark.includes('^') ? `\n${lineMark}\n` : '\n';
    return result;
}
function preparseMessage(message) {
    if (message.charAt(message.length - 1) === ':') {
        return message;
    }
    if (message.charAt(message.length - 1) === '.') {
        return `${message.substring(0, message.length - 1)} in:`;
    }
    return `${message} in:`;
}
function buildMessage(messageString, query, term, backtrace) {
    let message = messageString;
    const t = query ? query[1] : term;
    if (t) {
        message = preparseMessage(message);
        const [str, mark] = term_backtrace_1.backtraceTerm(t, true, backtrace);
        if (globals_1.globals.pretty) {
            message += `\n${pretty(str, mark)}`;
        }
        else {
            message += `\n${str}\n`;
            if (backtrace) {
                message += `${mark}\n`;
            }
        }
    }
    return message;
}
function getErrorNameAndType({ errorCode, type, responseErrorType, }) {
    if (type) {
        return { name: 'ReqlDriverError', type };
    }
    if (errorCode && errorCode >= 10 && errorCode <= 20) {
        // https://rethinkdb.com/docs/writing-drivers/
        // A ReqlAuthError should be thrown if the error code is between 10 and 20 (inclusive)
        // what about other error codes?
        return { name: 'ReqlAuthError', type: types_1.RethinkDBErrorType.AUTH };
    }
    switch (responseErrorType) {
        case enums_1.ErrorType.INTERNAL:
            return {
                name: 'ReqlInternalError',
                type: types_1.RethinkDBErrorType.INTERNAL,
            };
        case enums_1.ErrorType.NON_EXISTENCE:
            return {
                name: 'ReqlNonExistanceError',
                type: types_1.RethinkDBErrorType.NON_EXISTENCE,
            };
        case enums_1.ErrorType.OP_FAILED:
            return {
                name: 'ReqlOpFailedError',
                type: types_1.RethinkDBErrorType.OP_FAILED,
            };
        case enums_1.ErrorType.OP_INDETERMINATE:
            return {
                name: 'ReqlOpIndeterminateError',
                type: types_1.RethinkDBErrorType.OP_INDETERMINATE,
            };
        case enums_1.ErrorType.PERMISSION_ERROR:
            return {
                name: 'ReqlPermissionError',
                type: types_1.RethinkDBErrorType.PERMISSION_ERROR,
            };
        case enums_1.ErrorType.QUERY_LOGIC:
            return {
                name: 'ReqlLogicError',
                type: types_1.RethinkDBErrorType.QUERY_LOGIC,
            };
        case enums_1.ErrorType.RESOURCE_LIMIT:
            return {
                name: 'ReqlResourceError',
                type: types_1.RethinkDBErrorType.RESOURCE_LIMIT,
            };
        case enums_1.ErrorType.USER:
            return {
                name: 'ReqlUserError',
                type: types_1.RethinkDBErrorType.USER,
            };
        default:
            return { name: 'ReqlUnknownError', type: types_1.RethinkDBErrorType.UNKNOWN };
    }
}
class RethinkDBError extends Error {
    constructor(msg, { cause, type, term, query, errorCode, backtrace, responseErrorType, } = {}) {
        super(buildMessage(msg, query, term, backtrace));
        this.msg = msg;
        this.type = types_1.RethinkDBErrorType.UNKNOWN;
        this.cause = cause;
        this.name = 'ReqlDriverError';
        this.msg = msg;
        this.term = query ? query[1] : term;
        this.backtrace = backtrace;
        const { name, type: returnedType } = getErrorNameAndType({
            errorCode,
            responseErrorType,
            type,
        });
        this.name = name;
        this.type = returnedType;
        Error.captureStackTrace(this, RethinkDBError);
    }
    addBacktrace({ term, query, backtrace, } = {}) {
        this.message = buildMessage(this.msg, query, term, backtrace);
    }
}
exports.RethinkDBError = RethinkDBError;
function isRethinkDBError(error) {
    return error instanceof RethinkDBError;
}
exports.isRethinkDBError = isRethinkDBError;
