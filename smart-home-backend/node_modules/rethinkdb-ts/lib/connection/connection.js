"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RethinkDBConnection = void 0;
const events_1 = require("events");
const error_1 = require("../error/error");
const enums_1 = require("../proto/enums");
const globals_1 = require("../query-builder/globals");
const parse_opt_arg_1 = require("../query-builder/parse-opt-arg");
const cursor_1 = require("../response/cursor");
const types_1 = require("../types");
const socket_1 = require("./socket");
const util_1 = require("../util");
const tableQueries = [
    enums_1.TermType.TABLE_CREATE,
    enums_1.TermType.TABLE_DROP,
    enums_1.TermType.TABLE_LIST,
    enums_1.TermType.TABLE,
];
class RethinkDBConnection extends events_1.EventEmitter {
    constructor(connectionOptions, { db = 'test', user = 'admin', password = '', timeout = 20, pingInterval = -1, silent = false, log = (message) => undefined, } = {}) {
        super();
        this.connectionOptions = connectionOptions;
        this.db = 'test';
        this.options = socket_1.setConnectionDefaults(connectionOptions);
        this.clientPort = this.options.port || 28015;
        this.clientAddress = this.options.host || 'localhost';
        this.timeout = timeout;
        this.pingInterval = pingInterval;
        this.silent = silent;
        this.log = log;
        this.use(db);
        this.socket = new socket_1.RethinkDBSocket({
            connectionOptions: this.options,
            user,
            password,
        });
    }
    eventNames() {
        return ['release', 'close', 'timeout', 'error'];
    }
    get open() {
        return this.socket.status === 'open';
    }
    get numOfQueries() {
        return this.socket.runningQueries.size;
    }
    async close({ noreplyWait = false } = {}) {
        try {
            this.stopPinging();
            if (noreplyWait) {
                await this.noreplyWait();
            }
            await this.socket.close();
        }
        catch (err) {
            await this.socket.close();
            throw err;
        }
    }
    async reconnect(options) {
        if (this.socket.status === 'open' || this.socket.status === 'handshake') {
            await this.close(options);
        }
        this.socket
            .on('connect', () => this.emit('connect'))
            .on('close', (error) => {
            this.close();
            this.emit('close', error);
        })
            .on('error', (err) => {
            this.reportError(err);
        })
            .on('data', (data, token) => this.emit(data, token))
            .on('release', (count) => {
            if (count === 0) {
                this.emit('release');
            }
        });
        try {
            await Promise.race([util_1.delay(this.timeout * 1000), this.socket.connect()]);
        }
        catch (connectionError) {
            const error = new error_1.RethinkDBError('Unable to establish connection, see cause for more info.', {
                cause: connectionError,
                type: types_1.RethinkDBErrorType.CONNECTION,
            });
            this.reportError(error);
            this.emit('close', error);
            this.close();
            throw error;
        }
        if (this.socket.status === 'errored') {
            this.reportError(this.socket.lastError);
            this.emit('close', this.socket.lastError);
            this.close();
            throw this.socket.lastError;
        }
        if (this.socket.status !== 'open') {
            const error = new error_1.RethinkDBError(`Failed to connect to ${this.clientAddress}:${this.clientPort} in less than ${this.timeout}s.`, { type: types_1.RethinkDBErrorType.TIMEOUT });
            this.emit('timeout');
            this.emit('close', error);
            this.close().catch(() => undefined);
            throw error;
        }
        this.startPinging();
        return this;
    }
    use(db) {
        this.db = db;
    }
    async noreplyWait() {
        const token = this.socket.sendQuery([enums_1.QueryType.NOREPLY_WAIT]);
        const result = await this.socket.readNext(token);
        if (result.t !== enums_1.ResponseType.WAIT_COMPLETE) {
            if (this.socket.status === 'errored') {
                throw this.socket.lastError;
            }
            const err = new error_1.RethinkDBError('Unexpected return value');
            this.reportError(err);
            throw err;
        }
    }
    async server() {
        const token = this.socket.sendQuery([enums_1.QueryType.SERVER_INFO]);
        const result = await this.socket.readNext(token);
        if (result.t !== enums_1.ResponseType.SERVER_INFO) {
            if (this.socket.status === 'errored') {
                throw this.socket.lastError;
            }
            const err = new error_1.RethinkDBError('Unexpected return value');
            this.reportError(err);
            throw err;
        }
        return result.r[0];
    }
    async query(term, options = {}) {
        const { timeFormat, groupFormat, binaryFormat } = options, gargs = __rest(options, ["timeFormat", "groupFormat", "binaryFormat"]);
        gargs.db = gargs.db || this.db;
        this.findTableTermAndAddDb(term, gargs.db);
        if (globals_1.globals.arrayLimit !== undefined && gargs.arrayLimit === undefined) {
            gargs.arrayLimit = globals_1.globals.arrayLimit;
        }
        const query = [enums_1.QueryType.START, term];
        // @ts-ignore
        const optArgs = parse_opt_arg_1.parseOptarg(gargs);
        if (optArgs) {
            query.push(optArgs);
        }
        const token = this.socket.sendQuery(query);
        if (options.noreply) {
            return undefined;
        }
        return new cursor_1.Cursor(this.socket, token, options, query);
    }
    findTableTermAndAddDb(term, db) {
        if (!Array.isArray(term)) {
            if (term !== null && typeof term === 'object') {
                Object.values(term).forEach((value) => this.findTableTermAndAddDb(value, db));
                return;
            }
            return;
        }
        const termParam = term[1];
        if (tableQueries.includes(term[0])) {
            if (!termParam) {
                term[1] = [[enums_1.TermType.DB, [db]]];
                return;
            }
            const innerTerm = termParam[0];
            if (Array.isArray(innerTerm) && innerTerm[0] === enums_1.TermType.DB) {
                return;
            }
            termParam.unshift([enums_1.TermType.DB, [db]]);
            return;
        }
        if (termParam) {
            termParam.forEach((value) => this.findTableTermAndAddDb(value, db));
        }
    }
    startPinging() {
        if (this.pingInterval > 0) {
            this.pingTimer = setTimeout(async () => {
                try {
                    if (this.socket.status === 'open') {
                        const token = this.socket.sendQuery([
                            enums_1.QueryType.START,
                            [enums_1.TermType.ERROR, ['ping']],
                        ]);
                        const result = await this.socket.readNext(token);
                        if (result.t !== enums_1.ResponseType.RUNTIME_ERROR ||
                            result.e !== enums_1.ErrorType.USER ||
                            result.r[0] !== 'ping') {
                            this.reportError(new error_1.RethinkDBError('Ping error', { responseType: result.t }));
                        }
                    }
                }
                catch (e) {
                    this.reportError(e);
                }
                if (this.pingTimer) {
                    this.startPinging();
                }
            }, this.pingInterval);
        }
    }
    stopPinging() {
        if (this.pingTimer) {
            clearTimeout(this.pingTimer);
        }
        this.pingTimer = undefined;
    }
    reportError(err) {
        if (this.listenerCount('error') > 0) {
            this.emit('error', err);
        }
        if (!error_1.isRethinkDBError(err) || err.type !== types_1.RethinkDBErrorType.CANCEL) {
            this.log(err.toString());
            if (!this.silent) {
                console.error(err.toString());
            }
        }
    }
}
exports.RethinkDBConnection = RethinkDBConnection;
