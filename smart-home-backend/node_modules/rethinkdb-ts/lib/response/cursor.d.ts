/// <reference types="node" />
import { Readable } from 'stream';
import { RethinkDBSocket } from '../connection/socket';
import { RethinkDBError } from '../error/error';
import { QueryJson } from '../internal-types';
import { RCursor, RCursorType, RunOptions } from '../types';
export declare class Cursor extends Readable implements RCursor {
    private conn;
    private token;
    private runOptions;
    private query;
    get profile(): any;
    private _profile;
    private position;
    private type;
    private includeStates;
    private closed;
    private emitting;
    private resolving;
    private lastError;
    private results?;
    private hasNextBatch?;
    constructor(conn: RethinkDBSocket, token: number, runOptions: Pick<RunOptions, 'binaryFormat' | 'groupFormat' | 'timeFormat'>, query: QueryJson);
    init(): void;
    _read(): void;
    pause(): this;
    resume(): this;
    destroy(): void;
    _destroy(): void;
    toString(): string;
    getType(): RCursorType;
    close(): Promise<void>;
    next(): Promise<any>;
    toArray(): Promise<any[]>;
    each(cb: (error: RethinkDBError | undefined, row?: any) => boolean, onFinishedCallback?: () => void): Promise<void>;
    eachAsync(rowHandler: (row: any, rowFinished?: (error?: string) => any) => any, final?: (error: any) => any): Promise<void>;
    resolve(): Promise<any[] | undefined>;
    [Symbol.asyncIterator](): AsyncIterableIterator<any>;
    private _next;
    private getResults;
    private handleErrors;
    private handleResponseNotes;
}
export declare function isCursor<T = any>(cursor: any): cursor is RCursor<T>;
