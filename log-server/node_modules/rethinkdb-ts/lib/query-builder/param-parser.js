"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseParam = void 0;
const types_1 = require("../types");
const error_1 = require("../error/error");
const enums_1 = require("../proto/enums");
const globals_1 = require("./globals");
const query_1 = require("./query");
const query_runner_1 = require("./query-runner");
const util_1 = require("../util");
const has_implicit_var_1 = require("./has-implicit-var");
function parseParam(param, nestingLevel = globals_1.globals.nestingLevel) {
    if (nestingLevel === 0) {
        throw new error_1.RethinkDBError('Nesting depth limit exceeded.\nYou probably have a circular reference somewhere.', { type: types_1.RethinkDBErrorType.PARSE });
    }
    if (param === null) {
        return null;
    }
    if (query_1.isQuery(param)) {
        if (param.term === undefined) {
            throw new error_1.RethinkDBError("'r' cannot be an argument", {
                type: types_1.RethinkDBErrorType.PARSE,
            });
        }
        if (globals_1.globals.nextVarId === 1 &&
            nestingLevel === globals_1.globals.nestingLevel &&
            has_implicit_var_1.hasImplicitVar(param.term)) {
            return [enums_1.TermType.FUNC, [[enums_1.TermType.MAKE_ARRAY, [1]], param.term]];
        }
        return param.term;
    }
    if (Array.isArray(param)) {
        const arrTerm = [
            enums_1.TermType.MAKE_ARRAY,
            param.map((p) => parseParam(p, nestingLevel - 1)),
        ];
        if (has_implicit_var_1.hasImplicitVar(arrTerm)) {
            return [enums_1.TermType.FUNC, [[enums_1.TermType.MAKE_ARRAY, [1]], arrTerm]];
        }
        return arrTerm;
    }
    if (util_1.isDate(param)) {
        return {
            $reql_type$: 'TIME',
            epoch_time: param.getTime() / 1000,
            timezone: '+00:00',
        };
    }
    if (Buffer.isBuffer(param)) {
        return { $reql_type$: 'BINARY', data: param.toString('base64') };
    }
    if (util_1.isFunction(param)) {
        const { nextVarId } = globals_1.globals;
        globals_1.globals.nextVarId = nextVarId + param.length;
        try {
            const funcResult = param(...Array.from({ length: param.length }, (_, i) => query_runner_1.toQuery([enums_1.TermType.VAR, [i + nextVarId]])));
            if (funcResult === undefined) {
                throw new error_1.RethinkDBError(`Anonymous function returned \`undefined\`. Did you forget a \`return\`? in:\n${param.toString()}`, { type: types_1.RethinkDBErrorType.PARSE });
            }
            return [
                enums_1.TermType.FUNC,
                [
                    [
                        enums_1.TermType.MAKE_ARRAY,
                        Array.from({ length: param.length }, (_, i) => i + nextVarId),
                    ],
                    parseParam(funcResult),
                ],
            ];
        }
        finally {
            globals_1.globals.nextVarId = nextVarId;
        }
    }
    if (typeof param === 'object') {
        const objTerm = Object.entries(param).reduce((acc, [key, value]) => {
            acc[key] = parseParam(value, nestingLevel - 1);
            return acc;
        }, {});
        return has_implicit_var_1.hasImplicitVar(objTerm)
            ? [enums_1.TermType.FUNC, [[enums_1.TermType.MAKE_ARRAY, [1]], objTerm]]
            : objTerm;
    }
    if (typeof param === 'number' &&
        (Number.isNaN(param) || !Number.isFinite(param))) {
        throw new error_1.RethinkDBError(`Cannot convert \`${param}\` to JSON`, {
            type: types_1.RethinkDBErrorType.PARSE,
        });
    }
    return param;
}
exports.parseParam = parseParam;
