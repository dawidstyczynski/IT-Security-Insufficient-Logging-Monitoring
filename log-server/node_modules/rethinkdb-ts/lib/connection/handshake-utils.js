"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.compareDigest = exports.computeSaltedPassword = exports.validateVersion = exports.buildAuthBuffer = exports.NULL_BUFFER = void 0;
const crypto_1 = require("crypto");
const util_1 = require("util");
const types_1 = require("../types");
const error_1 = require("../error/error");
const enums_1 = require("../proto/enums");
exports.NULL_BUFFER = Buffer.from('\0', 'binary');
const PROTOCOL_VERSION = 0;
const AUTHENTICATION_METHOD = 'SCRAM-SHA-256';
const KEY_LENGTH = 32; // Because we are currently using SHA 256
const CACHE_PBKDF2 = {};
const pbkdf2Async = util_1.promisify(crypto_1.pbkdf2);
function xorBuffer(a, b) {
    const result = [];
    const len = Math.min(a.length, b.length);
    for (let i = 0; i < len; i += 1) {
        // eslint-disable-next-line no-bitwise
        result.push(a[i] ^ b[i]);
    }
    return Buffer.from(result);
}
function buildAuthBuffer(user) {
    const versionBuffer = Buffer.alloc(4);
    versionBuffer.writeInt32LE(enums_1.Version.V1_0, 0);
    const randomString = crypto_1.randomBytes(18).toString('base64');
    const mainBuffer = Buffer.from(JSON.stringify({
        protocol_version: PROTOCOL_VERSION,
        authentication_method: AUTHENTICATION_METHOD,
        authentication: `n,,n=${user},r=${randomString}`,
    }));
    const authBuffer = Buffer.concat([versionBuffer, mainBuffer, exports.NULL_BUFFER]);
    return { authBuffer, randomString };
}
exports.buildAuthBuffer = buildAuthBuffer;
function validateVersion(msg) {
    if (msg.max_protocol_version < PROTOCOL_VERSION ||
        msg.min_protocol_version > PROTOCOL_VERSION) {
        throw new error_1.RethinkDBError('Unsupported protocol version', {
            type: types_1.RethinkDBErrorType.UNSUPPORTED_PROTOCOL,
        });
    }
}
exports.validateVersion = validateVersion;
async function getSaltedPassword(password, salt, iterations) {
    const cacheKey = `${password.toString('base64')},${salt.toString('base64')},${iterations}`;
    if (!CACHE_PBKDF2[cacheKey]) {
        CACHE_PBKDF2[cacheKey] = await pbkdf2Async(password, salt, iterations, KEY_LENGTH, 'sha256');
    }
    return CACHE_PBKDF2[cacheKey];
}
async function computeSaltedPassword(authString, randomString, user, password) {
    const [randomNonce, s, i] = authString
        .split(',')
        .map((part) => part.substring(2));
    const salt = Buffer.from(s, 'base64');
    if (randomNonce.substring(0, randomString.length) !== randomString) {
        throw new error_1.RethinkDBError('Invalid nonce from server', {
            type: types_1.RethinkDBErrorType.AUTH,
        });
    }
    const saltedPassword = await getSaltedPassword(password, salt, Number.parseInt(i, 10));
    const clientFinalMessageWithoutProof = `c=biws,r=${randomNonce}`;
    const clientKey = crypto_1.createHmac('sha256', saltedPassword)
        .update('Client Key')
        .digest();
    const storedKey = crypto_1.createHash('sha256').update(clientKey).digest();
    const authMessage = `n=${user},r=${randomString},${authString},${clientFinalMessageWithoutProof}`;
    const clientSignature = crypto_1.createHmac('sha256', storedKey)
        .update(authMessage)
        .digest();
    const serverKey = crypto_1.createHmac('sha256', saltedPassword)
        .update('Server Key')
        .digest();
    const serverSignature = crypto_1.createHmac('sha256', serverKey)
        .update(authMessage)
        .digest()
        .toString('base64');
    const clientProof = xorBuffer(clientKey, clientSignature).toString('base64');
    const authentication = `${clientFinalMessageWithoutProof},p=${clientProof}`;
    return {
        serverSignature,
        proof: Buffer.concat([
            Buffer.from(JSON.stringify({ authentication })),
            exports.NULL_BUFFER,
        ]),
    };
}
exports.computeSaltedPassword = computeSaltedPassword;
function compareDigest(authentication, serverSignature) {
    if (authentication.substring(authentication.indexOf('=') + 1) !==
        serverSignature) {
        throw new error_1.RethinkDBError('Invalid server signature', {
            type: types_1.RethinkDBErrorType.AUTH,
        });
    }
}
exports.compareDigest = compareDigest;
